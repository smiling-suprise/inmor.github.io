<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>聚类算法对比平台</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5rem;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .panel {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 25px;
            flex: 1;
            min-width: 300px;
        }
        
        .panel-title {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            color: #2c3e50;
            font-size: 1.3rem;
        }
        
        .panel-title i {
            margin-right: 10px;
            color: #3498db;
        }
        
        .file-upload-area {
            border: 2px dashed #3498db;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }
        
        .file-upload-area:hover {
            background-color: #f8fafc;
            border-color: #2980b9;
        }
        
        .file-upload-area i {
            font-size: 3rem;
            color: #3498db;
            margin-bottom: 15px;
        }
        
        #fileInput {
            display: none;
        }
        
        .selected-files {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            margin-bottom: 8px;
        }
        
        .file-name {
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 70%;
        }
        
        .file-size {
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        
        .remove-file {
            color: #e74c3c;
            cursor: pointer;
            background: none;
            border: none;
            font-size: 1.2rem;
        }
        
        .data-preview {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        
        .data-table th, .data-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        .data-table th {
            background-color: #f2f2f2;
            font-weight: 600;
        }
        
        .data-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .algorithm-selector {
            margin-top: 25px;
        }
        
        .algorithm-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .algorithm-tab {
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .algorithm-tab.active {
            border-bottom-color: #3498db;
            color: #3498db;
        }
        
        .algorithm-content {
            display: none;
        }
        
        .algorithm-content.active {
            display: block;
        }
        
        .param-group {
            margin-bottom: 15px;
        }
        
        .param-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .param-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .feature-selector {
            margin-top: 15px;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
        }
        
        .feature-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .feature-item input {
            margin-right: 10px;
        }
        
        .algorithm-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .execute-btn {
            flex: 1;
            padding: 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .execute-btn:hover {
            background-color: #2980b9;
        }
        
        .execute-btn:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        .execute-all-btn {
            flex: 1;
            padding: 15px;
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .execute-all-btn:hover {
            background-color: #27ae60;
        }
        
        .execute-all-btn:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        .execute-btn i {
            margin-right: 10px;
        }
        
        .results-panel {
            flex: 2;
            min-width: 300px;
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .results-tabs {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .tab.active {
            border-bottom-color: #3498db;
            color: #3498db;
        }
        
        .tab-content {
            display: none;
            min-height: 300px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .algorithm-results {
            display: none;
        }
        
        .algorithm-results.active {
            display: block;
        }
        
        .text-output {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .chart-container {
            height: 300px;
            width: 100%;
            position: relative;
            margin-bottom: 20px;
        }
        
        .comparison-charts {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .chart-box {
            flex: 1;
            min-width: 300px;
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
        }
        
        .chart-title {
            text-align: center;
            margin-bottom: 15px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 1.1rem;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            font-weight: 500;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #7f8c8d;
            margin-right: 8px;
        }
        
        .status-dot.ready {
            background-color: #2ecc71;
        }
        
        .status-dot.running {
            background-color: #f39c12;
            animation: pulse 1.5s infinite;
        }
        
        .status-dot.complete {
            background-color: #3498db;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .stat-box {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border-left: 4px solid #3498db;
        }
        
        .stat-box.kmeans {
            border-left-color: #e74c3c;
        }
        
        .stat-box.dbscan {
            border-left-color: #2ecc71;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        
        .clustering-results {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
        }
        
        .cluster-box {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #e74c3c;
        }
        
        .cluster-box.kmeans-cluster {
            border-left-color: #e74c3c;
        }
        
        .cluster-box.dbscan-cluster {
            border-left-color: #2ecc71;
        }
        
        .cluster-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .cluster-title {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .cluster-count {
            background-color: #3498db;
            color: white;
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 0.9rem;
        }
        
        .cluster-count.kmeans {
            background-color: #e74c3c;
        }
        
        .cluster-count.dbscan {
            background-color: #2ecc71;
        }
        
        .cluster-samples {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-top: 5px;
        }
        
        .centroid-display {
            margin-top: 10px;
            font-size: 0.9rem;
        }
        
        .centroid-value {
            background-color: #ecf0f1;
            padding: 5px 10px;
            border-radius: 4px;
            margin-right: 10px;
            margin-bottom: 5px;
            display: inline-block;
        }
        
        .evaluation-metrics {
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric-item {
            text-align: center;
            padding: 10px;
            background-color: #34495e;
            border-radius: 5px;
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #3498db;
        }
        
        .metric-label {
            font-size: 0.9rem;
            color: #bdc3c7;
            margin-top: 5px;
        }
        
        .log-output {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9rem;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
        }
        
        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }
        
        .log-time {
            color: #7f8c8d;
            margin-right: 10px;
        }
        
        footer {
            text-align: center;
            color: #7f8c8d;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            font-size: 0.9rem;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 1.5rem;
            flex-direction: column;
            display: none;
        }
        
        .spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #3498db;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .comparison-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .comparison-metric-card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
        }
        
        .comparison-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .comparison-values {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-top: 15px;
        }
        
        .algorithm-value {
            text-align: center;
        }
        
        .algorithm-name {
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 1.1rem;
        }
        
        .kmeans-name {
            color: #e74c3c;
        }
        
        .dbscan-name {
            color: #2ecc71;
        }
        
        .algorithm-metric-value {
            font-size: 1.8rem;
            font-weight: 700;
        }
        
        .winner {
            position: relative;
        }
        
        .winner::after {
            content: "✓";
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: #2ecc71;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
        }
        
        .side-by-side-charts {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .side-by-side-chart-box {
            flex: 1;
            min-width: 300px;
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
            height: 350px;
            display: flex;
            flex-direction: column;
        }
        
        .side-by-side-chart-container {
            flex: 1;
            position: relative;
        }
        
        .mean-points {
            margin-top: 15px;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9rem;
        }
        
        .mean-point {
            display: inline-block;
            margin-right: 10px;
            margin-bottom: 5px;
            padding: 5px 10px;
            background-color: #ecf0f1;
            border-radius: 3px;
        }
        
        .invalid-data-info {
            background-color: #fff8e1;
            border-left: 4px solid #ff9800;
            padding: 10px 15px;
            margin-top: 15px;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .panel {
                width: 100%;
            }
            
            .comparison-charts {
                flex-direction: column;
            }
            
            .comparison-metrics {
                grid-template-columns: 1fr;
            }
            
            .side-by-side-charts {
                flex-direction: column;
            }
        }
        
        .prf1-metrics {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            border-left: 4px solid #3498db;
        }
        
        .prf1-title {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
        }
        
        .prf1-title i {
            margin-right: 8px;
            color: #3498db;
        }
        
        .prf1-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
        }
        
        .prf1-item {
            text-align: center;
            padding: 15px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        .prf1-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #2c3e50;
        }
        
        .prf1-label {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div>正在初始化环境...</div>
        <div id="loadingStatus" style="font-size: 1rem; margin-top: 10px;"></div>
    </div>
    
    <div class="container">
        <header>
            <h1><i class="fas fa-project-diagram"></i> 聚类算法对比平台</h1>
            <p class="subtitle">上传Excel数据文件，运行K-Means和DBSCAN算法并进行可视化对比</p>
        </header>
        
        <div class="main-content">
            <div class="panel">
                <div class="panel-title">
                    <i class="fas fa-file-upload"></i> 数据上传
                </div>
                
                <div class="file-upload-area" id="dropArea">
                    <i class="fas fa-file-excel"></i>
                    <p>拖拽Excel文件到此处或点击选择文件</p>
                    <p><small>支持 .xlsx, .xls, .csv 格式文件</small></p>
                    <input type="file" id="fileInput" accept=".xlsx,.xls,.csv">
                </div>
                
                <div class="selected-files" id="selectedFiles">
                    <!-- 已选择文件将显示在这里 -->
                </div>
                
                <div id="dataPreviewContainer" style="display: none;">
                    <div class="panel-title">
                        <i class="fas fa-table"></i> 数据预览
                    </div>
                    <div class="data-preview" id="dataPreview">
                        <!-- 数据预览表格将显示在这里 -->
                    </div>
                    
                    <div class="panel-title" style="margin-top: 20px;">
                        <i class="fas fa-check-circle"></i> 选择特征列
                    </div>
                    <div class="feature-selector" id="featureSelector">
                        <!-- 特征选择器将显示在这里 -->
                    </div>
                    
                    <div class="param-group">
                        <label class="param-label" for="labelColumn">标签列（可选）</label>
                        <select class="param-input" id="labelColumn">
                            <option value="">无标签列</option>
                            <!-- 标签列选项将动态添加 -->
                        </select>
                    </div>
                </div>
                
                <div class="algorithm-selector">
                    <div class="panel-title">
                        <i class="fas fa-sliders-h"></i> 算法配置
                    </div>
                    
                    <div class="algorithm-tabs">
                        <div class="algorithm-tab active" data-algorithm="kmeans">K-Means</div>
                        <div class="algorithm-tab" data-algorithm="dbscan">DBSCAN</div>
                    </div>
                    
                    <!-- K-Means配置 -->
                    <div class="algorithm-content active" id="kmeansConfig">
                        <div class="param-group">
                            <label class="param-label" for="kValue">聚类数量 (k)</label>
                            <input type="number" class="param-input" id="kValue" value="3" min="2" max="10">
                        </div>
                        
                        <div class="param-group">
                            <label class="param-label" for="maxIterations">最大迭代次数</label>
                            <input type="number" class="param-input" id="maxIterations" value="100" min="10" max="1000">
                        </div>
                        
                        <div class="param-group">
                            <label class="param-label" for="randomState">随机种子（可选）</label>
                            <input type="number" class="param-input" id="randomState" placeholder="留空则使用随机种子">
                        </div>
                        
                        <div class="param-group">
                            <label class="param-label">
                                <input type="checkbox" id="useCustomCentroids"> 使用自定义初始中心点
                            </label>
                            <div id="customCentroidsContainer" style="display: none; margin-top: 10px;">
                                <div id="centroidsInputs">
                                    <!-- 自定义中心点输入框将动态添加 -->
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- DBSCAN配置 -->
                    <div class="algorithm-content" id="dbscanConfig">
                        <div class="param-group">
                            <label class="param-label" for="eps">邻域半径 (eps)</label>
                            <input type="number" class="param-input" id="eps" step="0.1" value="0.5" placeholder="留空则自动估算">
                            <small style="color: #7f8c8d; display: block; margin-top: 5px;">留空则自动使用k-距离图法估算最优eps值</small>
                        </div>
                        
                        <div class="param-group">
                            <label class="param-label" for="minSamples">核心点最小样本数</label>
                            <input type="number" class="param-input" id="minSamples" value="5" placeholder="留空则自动估算">
                            <small style="color: #7f8c8d; display: block; margin-top: 5px;">留空则自动估算为max(3, 特征数+1)</small>
                        </div>
                        
                        <div class="param-group">
                            <label class="param-label">
                                <input type="checkbox" id="forceTwoClusters" checked> 强制二分类输出
                            </label>
                            <small style="color: #7f8c8d; display: block; margin-top: 5px;">强制将结果转换为两个主要聚类</small>
                        </div>
                        
                        <div class="param-group">
                            <label class="param-label">
                                <input type="checkbox" id="optimizeParams" checked> 自动优化参数
                            </label>
                            <small style="color: #7f8c8d; display: block; margin-top: 5px;">自动调整参数以减少噪声误判</small>
                        </div>
                    </div>
                    
                    <div class="algorithm-buttons">
                        <button class="execute-btn" id="executeSingleBtn" disabled>
                            <i class="fas fa-play-circle"></i> 运行选中算法
                        </button>
                        <button class="execute-all-btn" id="executeAllBtn" disabled>
                            <i class="fas fa-bolt"></i> 运行两种算法
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="panel results-panel">
                <div class="results-header">
                    <div class="panel-title">
                        <i class="fas fa-chart-bar"></i> 结果展示
                    </div>
                    <div class="status-indicator">
                        <div class="status-dot ready" id="statusDot"></div>
                        <span id="statusText">等待上传数据</span>
                    </div>
                </div>
                
                <div class="results-tabs">
                    <div class="tab active" data-tab="comparison">算法对比</div>
                    <div class="tab" data-tab="kmeansResults">K-Means结果</div>
                    <div class="tab" data-tab="dbscanResults">DBSCAN结果</div>
                    <div class="tab" data-tab="logs">运行日志</div>
                </div>
                
                <div class="tab-content active" id="comparisonTab">
                    <div id="comparisonResults">
                        <p style="color: #7f8c8d; text-align: center; margin-top: 50px;">
                            <i class="fas fa-info-circle"></i> 请上传数据并运行算法以查看对比结果
                        </p>
                    </div>
                </div>
                
                <div class="tab-content" id="kmeansResultsTab">
                    <div id="kmeansResults">
                        <p style="color: #7f8c8d; text-align: center; margin-top: 50px;">
                            <i class="fas fa-info-circle"></i> K-Means结果将在算法运行后显示
                        </p>
                    </div>
                </div>
                
                <div class="tab-content" id="dbscanResultsTab">
                    <div id="dbscanResults">
                        <p style="color: #7f8c8d; text-align: center; margin-top: 50px;">
                            <i class="fas fa-info-circle"></i> DBSCAN结果将在算法运行后显示
                        </p>
                    </div>
                </div>
                
                <div class="tab-content" id="logsTab">
                    <div class="log-output" id="logOutput">
                        <div class="log-entry"><span class="log-time">[系统]</span> 欢迎使用聚类算法对比平台</div>
                        <div class="log-entry"><span class="log-time">[系统]</span> 请上传Excel数据文件以开始</div>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>聚类算法对比平台 &copy; 2023 | 支持K-Means和DBSCAN算法对比与可视化</p>
        </footer>
    </div>

    <script>
        // 全局变量
        let selectedFiles = [];
        let currentData = null;
        let currentColumns = [];
        let numericColumns = [];
        let kmeansChart = null;
        let dbscanChart = null;
        let comparisonChart = null;
        let kmeansResult = null;
        let dbscanResult = null;
        
        // DOM 元素
        const fileInput = document.getElementById('fileInput');
        const dropArea = document.getElementById('dropArea');
        const selectedFilesDiv = document.getElementById('selectedFiles');
        const dataPreviewContainer = document.getElementById('dataPreviewContainer');
        const dataPreview = document.getElementById('dataPreview');
        const featureSelector = document.getElementById('featureSelector');
        const labelColumnSelect = document.getElementById('labelColumn');
        const executeSingleBtn = document.getElementById('executeSingleBtn');
        const executeAllBtn = document.getElementById('executeAllBtn');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingStatus = document.getElementById('loadingStatus');
        const logOutput = document.getElementById('logOutput');
        const comparisonResults = document.getElementById('comparisonResults');
        const kmeansResults = document.getElementById('kmeansResults');
        const dbscanResults = document.getElementById('dbscanResults');
        const kmeansConfig = document.getElementById('kmeansConfig');
        const dbscanConfig = document.getElementById('dbscanConfig');
        const centroidsInputs = document.getElementById('centroidsInputs');
        
        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            initEventListeners();
            addLog('系统初始化完成');
            updateStatus('ready', '就绪，等待上传数据');
        });
        
        // 初始化事件监听器
        function initEventListeners() {
            // 文件选择事件
            dropArea.addEventListener('click', () => fileInput.click());
            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropArea.style.borderColor = '#2980b9';
                dropArea.style.backgroundColor = '#f0f8ff';
            });
            dropArea.addEventListener('dragleave', () => {
                dropArea.style.borderColor = '#3498db';
                dropArea.style.backgroundColor = 'white';
            });
            dropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dropArea.style.borderColor = '#3498db';
                dropArea.style.backgroundColor = 'white';
                
                if (e.dataTransfer.files.length) {
                    handleFiles(e.dataTransfer.files);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length) {
                    handleFiles(e.target.files);
                }
            });
            
            // 算法选项卡切换
            document.querySelectorAll('.algorithm-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const algorithm = this.getAttribute('data-algorithm');
                    
                    // 移除所有选项卡的active类
                    document.querySelectorAll('.algorithm-tab').forEach(t => t.classList.remove('active'));
                    // 添加当前选项卡的active类
                    this.classList.add('active');
                    
                    // 隐藏所有算法配置
                    document.querySelectorAll('.algorithm-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    // 显示当前算法配置
                    document.getElementById(algorithm + 'Config').classList.add('active');
                });
            });
            
            // K-Means参数变化事件
            document.getElementById('kValue').addEventListener('change', updateCustomCentroidsInputs);
            document.getElementById('useCustomCentroids').addEventListener('change', function() {
                const container = document.getElementById('customCentroidsContainer');
                container.style.display = this.checked ? 'block' : 'none';
                if (this.checked) {
                    updateCustomCentroidsInputs();
                }
            });
            
            // 标签列选择事件
            labelColumnSelect.addEventListener('change', function() {
                if (this.value) {
                    const featureCheckboxes = featureSelector.querySelectorAll('input[type="checkbox"]');
                    featureCheckboxes.forEach(cb => {
                        if (cb.value === this.value) {
                            cb.checked = false;
                            cb.disabled = true;
                            cb.parentElement.style.opacity = '0.5';
                        }
                    });
                } else {
                    const featureCheckboxes = featureSelector.querySelectorAll('input[type="checkbox"]');
                    featureCheckboxes.forEach(cb => {
                        cb.disabled = false;
                        cb.parentElement.style.opacity = '1';
                    });
                }
            });
            
            // 执行按钮事件
            executeSingleBtn.addEventListener('click', runSelectedAlgorithm);
            executeAllBtn.addEventListener('click', runBothAlgorithms);
            
            // 结果选项卡切换事件
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    
                    // 移除所有选项卡的active类
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    // 添加当前选项卡的active类
                    this.classList.add('active');
                    
                    // 隐藏所有选项卡内容
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    // 显示当前选项卡内容
                    document.getElementById(tabId + 'Tab').classList.add('active');
                });
            });
        }
        
        // 处理文件选择
        function handleFiles(files) {
            selectedFiles = Array.from(files);
            updateSelectedFilesList();
            
            if (selectedFiles.length > 0) {
                const file = selectedFiles[0];
                readExcelFile(file);
            }
        }
        
        // 更新已选择文件列表
        function updateSelectedFilesList() {
            selectedFilesDiv.innerHTML = '';
            
            if (selectedFiles.length === 0) {
                return;
            }
            
            const file = selectedFiles[0];
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            
            const fileInfo = document.createElement('div');
            const fileName = document.createElement('div');
            fileName.className = 'file-name';
            fileName.textContent = file.name;
            
            const fileSize = document.createElement('div');
            fileSize.className = 'file-size';
            fileSize.textContent = formatFileSize(file.size);
            
            fileInfo.appendChild(fileName);
            fileInfo.appendChild(fileSize);
            
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-file';
            removeBtn.innerHTML = '<i class="fas fa-times"></i>';
            removeBtn.addEventListener('click', () => {
                selectedFiles = [];
                updateSelectedFilesList();
                dataPreviewContainer.style.display = 'none';
                executeSingleBtn.disabled = true;
                executeAllBtn.disabled = true;
                updateStatus('ready', '等待上传数据');
            });
            
            fileItem.appendChild(fileInfo);
            fileItem.appendChild(removeBtn);
            selectedFilesDiv.appendChild(fileItem);
        }
        
        // 读取Excel文件
        function readExcelFile(file) {
            addLog(`正在读取文件: ${file.name}`);
            updateStatus('running', '读取文件中...');
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);
                    
                    if (jsonData.length === 0) {
                        addLog('文件为空或无法读取数据', 'error');
                        updateStatus('ready', '文件为空');
                        return;
                    }
                    
                    currentData = jsonData;
                    currentColumns = Object.keys(jsonData[0]);
                    
                    numericColumns = [];
                    currentColumns.forEach(col => {
                        let isNumeric = true;
                        for (let i = 0; i < Math.min(10, jsonData.length); i++) {
                            const value = jsonData[i][col];
                            if (value === null || value === undefined || isNaN(Number(value))) {
                                isNumeric = false;
                                break;
                            }
                        }
                        
                        if (isNumeric) {
                            numericColumns.push(col);
                        }
                    });
                    
                    displayDataPreview();
                    displayFeatureSelector();
                    displayLabelColumnSelector();
                    
                    dataPreviewContainer.style.display = 'block';

                    executeSingleBtn.disabled = false;
                    executeAllBtn.disabled = false;
                    
                    addLog(`成功加载数据: ${jsonData.length} 行, ${currentColumns.length} 列`);
                    addLog(`检测到数值列: ${numericColumns.length} 个`);
                    updateStatus('ready', '数据加载完成');
                    
                } catch (error) {
                    addLog('读取文件失败: ' + error.message, 'error');
                    updateStatus('ready', '文件读取失败');
                    console.error('读取Excel文件失败:', error);
                }
            };
            
            reader.onerror = function() {
                addLog('读取文件时发生错误', 'error');
                updateStatus('ready', '文件读取错误');
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // 显示数据预览
        function displayDataPreview() {
            if (!currentData || currentData.length === 0) return;
            
            const previewData = currentData.slice(0, 10);
            
            let tableHTML = '<table class="data-table"><thead><tr>';
            
            currentColumns.forEach(col => {
                tableHTML += `<th>${col}</th>`;
            });
            
            tableHTML += '</tr></thead><tbody>';
            
            previewData.forEach(row => {
                tableHTML += '<tr>';
                currentColumns.forEach(col => {
                    const value = row[col];
                    tableHTML += `<td>${value !== null && value !== undefined ? value : ''}</td>`;
                });
                tableHTML += '</tr>';
            });
            
            tableHTML += '</tbody></table>';
            
            if (currentData.length > 10) {
                tableHTML += `<p style="text-align: center; color: #7f8c8d; margin-top: 10px;">... 只显示前10行，共${currentData.length}行</p>`;
            }
            
            dataPreview.innerHTML = tableHTML;
        }
        
        // 显示特征选择器
        function displayFeatureSelector() {
            if (numericColumns.length === 0) {
                featureSelector.innerHTML = '<p style="color: #e74c3c;">未检测到数值列，请检查数据格式</p>';
                return;
            }
            
            let featureHTML = '';
            
            numericColumns.forEach((col, index) => {
                const isChecked = index < 2;
                featureHTML += `
                    <div class="feature-item">
                        <input type="checkbox" id="feature_${index}" value="${col}" ${isChecked ? 'checked' : ''}>
                        <label for="feature_${index}">${col}</label>
                    </div>
                `;
            });
            
            featureSelector.innerHTML = featureHTML;
            
            const featureCheckboxes = featureSelector.querySelectorAll('input[type="checkbox"]');
            featureCheckboxes.forEach(cb => {
                cb.addEventListener('change', function() {
                    const checkedCount = Array.from(featureCheckboxes).filter(c => c.checked).length;
                    if (checkedCount === 0) {
                        this.checked = true;
                    }
                });
            });
        }
        
        // 显示标签列选择器
        function displayLabelColumnSelector() {
            let options = '<option value="">无标签列</option>';
            
            currentColumns.forEach(col => {
                const isSelectedAsFeature = Array.from(featureSelector.querySelectorAll('input[type="checkbox"]:checked'))
                    .some(cb => cb.value === col);
                
                if (!isSelectedAsFeature) {
                    options += `<option value="${col}">${col}</option>`;
                }
            });
            
            labelColumnSelect.innerHTML = options;
        }
        
        // 更新自定义中心点输入框
        function updateCustomCentroidsInputs() {
            const useCustomCentroidsCheckbox = document.getElementById('useCustomCentroids');
            if (!useCustomCentroidsCheckbox.checked) return;
            
            const k = parseInt(document.getElementById('kValue').value) || 3;
            const selectedFeatures = getSelectedFeatures();
            
            if (selectedFeatures.length === 0) {
                centroidsInputs.innerHTML = '<p style="color: #e74c3c;">请先选择特征列</p>';
                return;
            }
            
            let html = '<p style="margin-bottom: 10px; color: #7f8c8d;">为每个中心点输入特征值:</p>';
            
            for (let i = 0; i < k; i++) {
                html += `<div style="margin-bottom: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 5px;">`;
                html += `<div style="font-weight: 600; margin-bottom: 8px;">中心点 ${i+1}:</div>`;
                
                selectedFeatures.forEach((feature, j) => {
                    html += `
                        <div style="display: flex; align-items: center; margin-bottom: 5px;">
                            <label style="width: 100px; font-size: 0.9rem;">${feature}:</label>
                            <input type="number" step="0.01" class="param-input" 
                                   style="flex: 1; padding: 5px;"
                                   id="centroid_${i}_${j}" 
                                   placeholder="输入${feature}的值">
                        </div>
                    `;
                });
                
                html += `</div>`;
            }
            
            centroidsInputs.innerHTML = html;
        }
        
        // 获取选中的特征列
        function getSelectedFeatures() {
            const featureCheckboxes = featureSelector.querySelectorAll('input[type="checkbox"]:checked');
            return Array.from(featureCheckboxes).map(cb => cb.value);
        }
        
        // 获取自定义中心点
        function getCustomCentroids() {
            const useCustomCentroidsCheckbox = document.getElementById('useCustomCentroids');
            if (!useCustomCentroidsCheckbox.checked) return null;
            
            const k = parseInt(document.getElementById('kValue').value) || 3;
            const selectedFeatures = getSelectedFeatures();
            const centroids = [];
            
            for (let i = 0; i < k; i++) {
                const centroid = [];
                let isValid = true;
                
                for (let j = 0; j < selectedFeatures.length; j++) {
                    const input = document.getElementById(`centroid_${i}_${j}`);
                    const value = parseFloat(input.value);
                    
                    if (isNaN(value)) {
                        addLog(`中心点 ${i+1} 的特征 ${selectedFeatures[j]} 输入无效`, 'error');
                        isValid = false;
                        break;
                    }
                    
                    centroid.push(value);
                }
                
                if (!isValid) {
                    return null;
                }
                
                centroids.push(centroid);
            }
            
            return centroids;
        }
        
        // 运行选中的算法
        function runSelectedAlgorithm() {
            const activeTab = document.querySelector('.algorithm-tab.active');
            const algorithm = activeTab.getAttribute('data-algorithm');
            
            if (algorithm === 'kmeans') {
                runKMeansAlgorithm();
            } else if (algorithm === 'dbscan') {
                runDBSCANAlgorithm();
            }
        }
        
        // 运行两种算法
        async function runBothAlgorithms() {
            updateStatus('running', '运行K-Means和DBSCAN算法...');
            executeSingleBtn.disabled = true;
            executeAllBtn.disabled = true;
            
            addLog('开始同时运行K-Means和DBSCAN算法...');
            
            loadingOverlay.style.display = 'flex';
            loadingStatus.textContent = '正在运行算法...';
            
            try {
                // 先运行K-Means
                await runKMeansAlgorithm(true);
                // 再运行DBSCAN
                await runDBSCANAlgorithm(true);
                
                // 显示对比结果
                displayComparisonResults();
                document.querySelector('.tab[data-tab="comparison"]').click();
                
                addLog('K-Means和DBSCAN算法运行完成');
                updateStatus('complete', '算法运行完成');
            } catch (error) {
                addLog(`算法运行出错: ${error.message}`, 'error');
                updateStatus('ready', '算法运行出错');
            } finally {
                loadingOverlay.style.display = 'none';
                executeSingleBtn.disabled = false;
                executeAllBtn.disabled = false;
            }
        }
        
        // 运行K-Means算法
        async function runKMeansAlgorithm(isParallel = false) {
            if (!currentData || currentData.length === 0) {
                addLog('没有可用的数据，请先上传文件', 'error');
                return;
            }
            
            const selectedFeatures = getSelectedFeatures();
            if (selectedFeatures.length === 0) {
                addLog('请至少选择一个特征列', 'error');
                return;
            }
            
            const k = parseInt(document.getElementById('kValue').value) || 3;
            const maxIterations = parseInt(document.getElementById('maxIterations').value) || 100;
            const randomStateInput = document.getElementById('randomState').value;
            const randomState = randomStateInput ? parseInt(randomStateInput) : null;
            const labelColumn = labelColumnSelect.value || null;
            
            if (k > currentData.length) {
                addLog(`聚类数量k(${k})不能大于样本数量(${currentData.length})`, 'error');
                return;
            }
            
            const customCentroids = getCustomCentroids();
            
            if (!isParallel) {
                executeSingleBtn.disabled = true;
                updateStatus('running', 'K-Means算法运行中...');
                addLog('开始运行K-Means算法...');
                loadingOverlay.style.display = 'flex';
                loadingStatus.textContent = '正在运行K-Means算法...';
            }
            
            try {
                // 准备数据
                const X_data = [];
                for (let row of currentData) {
                    const row_data = [];
                    for (let feature of selectedFeatures) {
                        row_data.push(parseFloat(row[feature]));
                    }
                    X_data.push(row_data);
                }
                
                const result = await runKMeansJavaScript(X_data, k, maxIterations, randomState, customCentroids);
                
                kmeansResult = result;
                displayKMeansResults(result);
                if (!isParallel) {
                    addLog('K-Means算法运行完成');
                    updateStatus('complete', '算法运行完成');
                    document.querySelector('.tab[data-tab="kmeansResults"]').click();
                }
                
            } catch (error) {
                addLog(`K-Means算法运行出错: ${error.message}`, 'error');
                if (!isParallel) {
                    updateStatus('ready', '算法运行出错');
                }
                console.error('运行K-Means算法出错:', error);
            } finally {
                if (!isParallel) {
                    loadingOverlay.style.display = 'none';
                    executeSingleBtn.disabled = false;
                }
            }
        }
        
        // JavaScript实现的K-Means算法 - 严格按照伪代码
        function runKMeansJavaScript(X, k, maxIterations, randomState, initialCentroids) {
            return new Promise((resolve) => {
                // 设置随机种子
                if (randomState !== null) {
                    Math.seedrandom(randomState.toString());
                }
                
                const m = X.length; // 样本数
                const n = X[0].length; // 特征维度
                let centroids;
                let clusters = new Array(k).fill().map(() => []); // 初始化k个空簇
                let labels = new Array(m).fill(0);
                const history = [];
                
                // 1. 初始化均值向量
                if (initialCentroids !== null && initialCentroids.length === k) {
                    centroids = initialCentroids.map(arr => [...arr]);
                } else {
                    // 从样本集中随机选择k个样本作为初始均值向量
                    const indices = [];
                    while (indices.length < k) {
                        const idx = Math.floor(Math.random() * m);
                        if (!indices.includes(idx)) indices.push(idx);
                    }
                    centroids = indices.map(idx => [...X[idx]]);
                }
                
                let logOutput = "K-Means算法执行过程:\n";
                logOutput += "初始均值向量:\n";
                for (let i = 0; i < centroids.length; i++) {
                    const centroidStr = centroids[i].map(coord => coord.toFixed(3)).join(", ");
                    logOutput += `  μ${i+1} = [${centroidStr}]\n`;
                }
                
                history.push([...centroids.map(c => [...c])]);
                
                // 2. 开始迭代
                let iteration;
                for (iteration = 0; iteration < maxIterations; iteration++) {
                    // 2.1 令所有簇为空
                    clusters = new Array(k).fill().map(() => []);
                    
                    // 2.2 对每个样本计算距离并分配到最近簇
                    for (let j = 0; j < m; j++) {
                        // 计算样本到每个均值向量的距离
                        let minDist = Infinity;
                        let clusterIdx = 0;
                        
                        for (let i = 0; i < k; i++) {
                            let dist = 0;
                            for (let d = 0; d < n; d++) {
                                dist += (X[j][d] - centroids[i][d]) ** 2;
                            }
                            dist = Math.sqrt(dist); // 欧氏距离
                            
                            if (dist < minDist) {
                                minDist = dist;
                                clusterIdx = i;
                            }
                        }
                        
                        // 将样本划入相应的簇
                        clusters[clusterIdx].push(j);
                        labels[j] = clusterIdx;
                    }
                    
                    // 2.3 更新均值向量
                    const newCentroids = new Array(k).fill().map(() => new Array(n).fill(0));
                    for (let i = 0; i < k; i++) {
                        if (clusters[i].length > 0) {
                            // 计算新均值向量
                            for (let d = 0; d < n; d++) {
                                let sum = 0;
                                for (let idx of clusters[i]) {
                                    sum += X[idx][d];
                                }
                                newCentroids[i][d] = sum / clusters[i].length;
                            }
                        } else {
                            // 如果簇为空，保持原均值向量不变
                            newCentroids[i] = [...centroids[i]];
                        }
                    }
                    
                    history.push([...newCentroids.map(c => [...c])]);
                    
                    // 2.4 检查均值向量是否更新
                    let updated = false;
                    for (let i = 0; i < k; i++) {
                        for (let d = 0; d < n; d++) {
                            if (Math.abs(newCentroids[i][d] - centroids[i][d]) > 1e-6) {
                                updated = true;
                                break;
                            }
                        }
                        if (updated) break;
                    }
                    
                    // 2.5 更新均值向量
                    centroids = newCentroids;
                    
                    // 2.6 如果均值向量未更新，则退出循环
                    if (!updated) {
                        logOutput += `\n第${iteration + 1}轮迭代后算法收敛\n`;
                        break;
                    }
                }
                
                if (iteration === maxIterations - 1) {
                    logOutput += `\n达到最大迭代次数 ${maxIterations}\n`;
                }
                
                logOutput += `总共迭代次数: ${iteration + 1}\n`;
                
                // 显示最终中心点
                logOutput += `\n最终均值向量:\n`;
                for (let i = 0; i < centroids.length; i++) {
                    const centroidStr = centroids[i].map(coord => coord.toFixed(3)).join(", ");
                    logOutput += `  μ${i+1} = [${centroidStr}]\n`;
                }
                
                // 计算PRF1指标
                const prf1Metrics = calculatePRF1ForKMeans(clusters, labels, k);
                
                const result = {
                    success: true,
                    algorithm: 'kmeans',
                    X: X,
                    labels: labels,
                    centroids: centroids,
                    clusters: clusters,
                    history: history,
                    log: logOutput,
                    features: getSelectedFeatures(),
                    n_samples: X.length,
                    n_features: X[0].length,
                    prf1: prf1Metrics
                };
                
                resolve(result);
            });
        }
        
        // 计算K-Means的PRF1指标
        function calculatePRF1ForKMeans(clusters, labels, k) {
            // 计算每个簇的大小
            const clusterSizes = clusters.map(cluster => cluster.length);
            
            // 找到最大的簇作为正例，最小的簇作为反例
            const maxSize = Math.max(...clusterSizes);
            const minSize = Math.min(...clusterSizes.filter(size => size > 0)); // 排除空簇
            
            const positiveClusterIdx = clusterSizes.indexOf(maxSize);
            const negativeClusterIdx = clusterSizes.indexOf(minSize);
            
            // 计算混淆矩阵
            let TP = 0, FP = 0, FN = 0, TN = 0;
            
            for (let i = 0; i < labels.length; i++) {
                if (labels[i] === positiveClusterIdx) {
                    // 真正例：被正确标记为正例的样本
                    TP++;
                } else if (labels[i] === negativeClusterIdx) {
                    // 真反例：被正确标记为反例的样本
                    TN++;
                }
                // 注意：在多聚类情况下，其他簇的样本被视为假反例或假正例
            }
            
            // 对于K-Means，我们需要考虑所有其他簇的样本
            // 假正例：被错误标记为正例的样本（实际上属于其他簇）
            FP = clusters.filter((_, idx) => idx !== positiveClusterIdx)
                .reduce((sum, cluster) => sum + cluster.length, 0);
            
            // 假反例：被错误标记为反例的样本（实际上属于正例簇但被分到其他簇）
            FN = 0; // 在二分类视角下，FN为0
            
            // 计算查准率、查全率和F1
            const P = TP / (TP + FP);
            const R = TP / (TP + FN);
            const F1 = (2 * P * R) / (P + R);
            
            // 使用简化公式：F1 = 2 * TP / (样例总数 + TP - TN)
            const totalSamples = labels.length;
            const F1_simplified = (2 * TP) / (totalSamples + TP - TN);
            
            return {
                TP: TP,
                FP: FP,
                FN: FN,
                TN: TN,
                precision: P || 0,
                recall: R || 0,
                f1: F1 || 0,
                f1_simplified: F1_simplified || 0,
                positive_cluster: positiveClusterIdx,
                negative_cluster: negativeClusterIdx,
                positive_cluster_size: maxSize,
                negative_cluster_size: minSize
            };
        }
        
        // 运行DBSCAN算法
        async function runDBSCANAlgorithm(isParallel = false) {
            if (!currentData || currentData.length === 0) {
                addLog('没有可用的数据，请先上传文件', 'error');
                return;
            }
            
            const selectedFeatures = getSelectedFeatures();
            if (selectedFeatures.length === 0) {
                addLog('请至少选择一个特征列', 'error');
                return;
            }
            
            const epsInput = document.getElementById('eps').value;
            const minSamplesInput = document.getElementById('minSamples').value;
            const forceTwoClusters = document.getElementById('forceTwoClusters').checked;
            const optimizeParams = document.getElementById('optimizeParams').checked;
            const labelColumn = labelColumnSelect.value || null;
            
            if (!isParallel) {
                executeSingleBtn.disabled = true;
                updateStatus('running', 'DBSCAN算法运行中...');
                addLog('开始运行DBSCAN算法...');
                loadingOverlay.style.display = 'flex';
                loadingStatus.textContent = '正在运行DBSCAN算法...';
            }
            
            try {
                // 准备数据
                const X_data = [];
                const validDataIndices = [];
                
                // 过滤无效数据
                for (let i = 0; i < currentData.length; i++) {
                    const row = currentData[i];
                    let isValid = true;
                    const row_data = [];
                    
                    for (let feature of selectedFeatures) {
                        const value = parseFloat(row[feature]);
                        if (isNaN(value)) {
                            isValid = false;
                            break;
                        }
                        row_data.push(value);
                    }
                    
                    if (isValid) {
                        X_data.push(row_data);
                        validDataIndices.push(i);
                    }
                }
                
                if (X_data.length === 0) {
                    addLog('没有有效的数据点，请检查数据质量', 'error');
                    if (!isParallel) {
                        updateStatus('ready', '数据无效');
                        executeSingleBtn.disabled = false;
                    }
                    return;
                }
                
                addLog(`有效数据点: ${X_data.length}/${currentData.length} (过滤了${currentData.length - X_data.length}个无效数据点)`);
                
                // 自动确定参数
                let eps = epsInput ? parseFloat(epsInput) : null;
                let minSamples = minSamplesInput ? parseInt(minSamplesInput) : null;
                
                // 如果开启了自动优化参数或参数为空，则自动确定参数
                if (optimizeParams || eps === null || minSamples === null) {
                    addLog('正在自动确定DBSCAN最优参数...');
                    const { optimalEps, optimalMinSamples } = estimateDBSCANParameters(X_data, selectedFeatures.length);
                    
                    if (eps === null) eps = optimalEps;
                    if (minSamples === null) minSamples = optimalMinSamples;
                    
                    addLog(`自动确定参数: eps=${eps.toFixed(4)}, min_samples=${minSamples}`);
                }
                
                const result = await runDBSCANJavaScript(X_data, eps, minSamples, forceTwoClusters, optimizeParams, validDataIndices);
                
                dbscanResult = result;
                displayDBSCANResults(result);
                if (!isParallel) {
                    addLog('DBSCAN算法运行完成');
                    updateStatus('complete', '算法运行完成');
                    document.querySelector('.tab[data-tab="dbscanResults"]').click();
                }
                
            } catch (error) {
                addLog(`DBSCAN算法运行出错: ${error.message}`, 'error');
                if (!isParallel) {
                    updateStatus('ready', '算法运行出错');
                }
                console.error('运行DBSCAN算法出错:', error);
            } finally {
                if (!isParallel) {
                    loadingOverlay.style.display = 'none';
                    executeSingleBtn.disabled = false;
                }
            }
        }
        
        // 自动估计DBSCAN参数（基于k-距离图法）
        function estimateDBSCANParameters(X, n_features) {
            const m = X.length;
            if (m < 10) {
                return { optimalEps: 0.5, optimalMinSamples: Math.max(3, n_features + 1) };
            }
            
            // 1. 确定min_samples的合理值
            // 一般规则：min_samples = 维度 + 1，但至少为3
            const minSamples = Math.max(3, n_features + 1);
            
            // 2. 使用k-距离图法确定eps
            // 计算每个点到第k近邻的距离
            const k = Math.min(minSamples, m - 1);
            const distances = [];
            
            for (let i = 0; i < m; i++) {
                const pointDistances = [];
                for (let j = 0; j < m; j++) {
                    if (i === j) continue;
                    
                    // 计算欧氏距离
                    let dist = 0;
                    for (let d = 0; d < n_features; d++) {
                        dist += (X[i][d] - X[j][d]) ** 2;
                    }
                    dist = Math.sqrt(dist);
                    pointDistances.push(dist);
                }
                
                // 排序并获取第k小的距离
                pointDistances.sort((a, b) => a - b);
                distances.push(pointDistances[k - 1]);
            }
            
            // 排序距离
            distances.sort((a, b) => a - b);
            
            // 寻找"拐点" - 距离变化最大的点
            let maxChange = 0;
            let optimalIndex = Math.floor(distances.length * 0.75); // 默认使用75%分位数
            
            // 寻找斜率变化最大的点
            for (let i = 1; i < distances.length - 1; i++) {
                const prevDiff = distances[i] - distances[i-1];
                const nextDiff = distances[i+1] - distances[i];
                const change = nextDiff - prevDiff;
                
                if (change > maxChange && i > distances.length * 0.1) {
                    maxChange = change;
                    optimalIndex = i;
                }
            }
            
            // 使用拐点处的距离作为eps
            let optimalEps = distances[optimalIndex];
            
            // 确保eps不太小也不太大
            if (optimalEps < 0.1) optimalEps = 0.1;
            if (optimalEps > 10) optimalEps = 10;
            
            // 如果数据量很大，可以稍微增大eps
            if (m > 1000) {
                optimalEps *= 1.2;
            }
            
            return { optimalEps, optimalMinSamples: minSamples };
        }
        
        // JavaScript实现的DBSCAN算法 - 改进版（修复版）
        function runDBSCANJavaScript(X, eps, minSamples, forceTwoClusters, optimizeParams, validDataIndices) {
            return new Promise((resolve) => {
                const m = X.length; // 样本数
                let labels = new Array(m).fill(-1); // 改为let声明，可以重新赋值
                let cluster_id = 0; // 聚类ID从0开始
                const visited = new Array(m).fill(false); // 标记样本是否已访问
                
                // 预计算距离矩阵以提高性能（对于小型数据集）
                let distanceMatrix = null;
                if (m <= 1000) {
                    distanceMatrix = precomputeDistances(X);
                }
                
                // 1. 确定核心对象
                const coreObjects = [];
                const pointNeighbors = new Array(m).fill().map(() => []);
                
                for (let j = 0; j < m; j++) {
                    // 获取样本的ε-邻域
                    const neighbors = [];
                    for (let i = 0; i < m; i++) {
                        if (i === j) continue;
                        
                        // 计算欧氏距离
                        let dist;
                        if (distanceMatrix) {
                            dist = distanceMatrix[j][i];
                        } else {
                            dist = 0;
                            for (let d = 0; d < X[0].length; d++) {
                                dist += (X[j][d] - X[i][d]) ** 2;
                            }
                            dist = Math.sqrt(dist);
                        }
                        
                        if (dist <= eps) {
                            neighbors.push(i);
                        }
                    }
                    
                    pointNeighbors[j] = neighbors;
                    
                    // 如果邻域内的样本数大于等于minSamples，则为核心对象
                    if (neighbors.length >= minSamples) {
                        coreObjects.push(j);
                    }
                }
                
                // 2. 开始聚类
                while (coreObjects.length > 0) {
                    // 随机选择一个核心对象
                    const randomIndex = Math.floor(Math.random() * coreObjects.length);
                    const coreObject = coreObjects[randomIndex];
                    
                    // 如果核心对象已被访问，则跳过
                    if (visited[coreObject]) {
                        coreObjects.splice(randomIndex, 1);
                        continue;
                    }
                    
                    // 标记为已访问
                    visited[coreObject] = true;
                    
                    // 初始化队列
                    const queue = [coreObject];
                    labels[coreObject] = cluster_id;
                    
                    // 开始扩展聚类
                    while (queue.length > 0) {
                        const currentPoint = queue.shift();
                        const currentNeighbors = pointNeighbors[currentPoint];
                        
                        // 如果当前点是核心对象
                        if (currentNeighbors.length >= minSamples) {
                            for (let neighbor of currentNeighbors) {
                                if (!visited[neighbor]) {
                                    visited[neighbor] = true;
                                    queue.push(neighbor);
                                }
                                
                                if (labels[neighbor] === -1) {
                                    labels[neighbor] = cluster_id;
                                }
                            }
                        }
                    }
                    
                    // 从核心对象集合中移除当前聚类中的点
                    for (let i = coreObjects.length - 1; i >= 0; i--) {
                        if (labels[coreObjects[i]] !== -1) {
                            coreObjects.splice(i, 1);
                        }
                    }
                    
                    cluster_id++;
                }
                
                // 3. 后处理：减少噪声误判
                let processedLabels = [...labels]; // 创建副本
                if (optimizeParams) {
                    processedLabels = postProcessDBSCAN(processedLabels, pointNeighbors, eps, minSamples);
                }
                
                // 4. 强制二分类
                if (forceTwoClusters && cluster_id > 2) {
                    processedLabels = forceTwoClustersDBSCAN(processedLabels);
                }
                
                // 5. 计算聚类中心点
                const centroids = calculateDBSCANCentroids(X, processedLabels);
                
                // 6. 计算PRF1指标
                const prf1Metrics = calculatePRF1ForDBSCAN(processedLabels);
                
                const result = {
                    success: true,
                    algorithm: 'dbscan',
                    X: X,
                    labels: processedLabels, // 使用处理后的标签
                    centroids: centroids,
                    features: getSelectedFeatures(),
                    n_samples: X.length,
                    n_features: X[0].length,
                    eps: eps,
                    min_samples: minSamples,
                    noise_count: processedLabels.filter(l => l === -1).length,
                    prf1: prf1Metrics,
                    invalid_data_count: currentData.length - X.length,
                    validDataIndices: validDataIndices
                };
                
                resolve(result);
            });
        }
        
        // 预计算距离矩阵
        function precomputeDistances(X) {
            const m = X.length;
            const n = X[0].length;
            const distances = new Array(m).fill().map(() => new Array(m).fill(0));
            
            for (let i = 0; i < m; i++) {
                for (let j = i + 1; j < m; j++) {
                    let dist = 0;
                    for (let d = 0; d < n; d++) {
                        dist += (X[i][d] - X[j][d]) ** 2;
                    }
                    dist = Math.sqrt(dist);
                    distances[i][j] = dist;
                    distances[j][i] = dist;
                }
            }
            
            return distances;
        }
        
        // DBSCAN后处理：减少噪声误判
        function postProcessDBSCAN(labels, pointNeighbors, eps, minSamples) {
            const m = labels.length;
            const newLabels = [...labels];
            
            // 尝试重新分配噪声点到最近的聚类
            for (let i = 0; i < m; i++) {
                if (newLabels[i] === -1) {
                    // 找到该点的所有邻居
                    const neighbors = pointNeighbors[i];
                    
                    // 统计邻居的标签分布
                    const labelCounts = {};
                    for (let neighbor of neighbors) {
                        if (newLabels[neighbor] !== -1) {
                            const label = newLabels[neighbor];
                            labelCounts[label] = (labelCounts[label] || 0) + 1;
                        }
                    }
                    
                    // 如果有足够多的邻居属于同一个聚类，则将该点分配到这个聚类
                    if (Object.keys(labelCounts).length > 0) {
                        const maxLabel = Object.keys(labelCounts).reduce((a, b) => 
                            labelCounts[a] > labelCounts[b] ? a : b
                        );
                        
                        if (labelCounts[maxLabel] >= Math.floor(minSamples / 2)) {
                            newLabels[i] = parseInt(maxLabel);
                        }
                    }
                }
            }
            
            // 合并小的聚类
            const labelSizes = {};
            for (let label of newLabels) {
                if (label !== -1) {
                    labelSizes[label] = (labelSizes[label] || 0) + 1;
                }
            }
            
            // 合并非常小的聚类到最近的聚类
            const smallClusters = Object.entries(labelSizes)
                .filter(([label, size]) => size < minSamples)
                .map(([label]) => parseInt(label));
                
            for (let smallCluster of smallClusters) {
                // 找到这个聚类的点
                const clusterPoints = [];
                for (let i = 0; i < m; i++) {
                    if (newLabels[i] === smallCluster) {
                        clusterPoints.push(i);
                    }
                }
                
                // 为每个点找到最近的聚类
                for (let pointIdx of clusterPoints) {
                    const neighbors = pointNeighbors[pointIdx];
                    const neighborLabels = {};
                    
                    for (let neighbor of neighbors) {
                        if (newLabels[neighbor] !== -1 && newLabels[neighbor] !== smallCluster) {
                            const label = newLabels[neighbor];
                            neighborLabels[label] = (neighborLabels[label] || 0) + 1;
                        }
                    }
                    
                    if (Object.keys(neighborLabels).length > 0) {
                        const bestLabel = Object.keys(neighborLabels).reduce((a, b) => 
                            neighborLabels[a] > neighborLabels[b] ? a : b
                        );
                        newLabels[pointIdx] = parseInt(bestLabel);
                    }
                }
            }
            
            // 重新编号标签
            const uniqueLabels = [...new Set(newLabels.filter(l => l !== -1))];
            const labelMap = {};
            uniqueLabels.forEach((label, index) => {
                labelMap[label] = index;
            });
            
            for (let i = 0; i < m; i++) {
                if (newLabels[i] !== -1) {
                    newLabels[i] = labelMap[newLabels[i]];
                }
            }
            
            return newLabels;
        }
        
        // 强制DBSCAN二分类
        function forceTwoClustersDBSCAN(labels) {
            const m = labels.length;
            const newLabels = [...labels];
            
            // 统计每个聚类的样本数
            const clusterCounts = {};
            for (let label of newLabels) {
                if (label !== -1) {
                    clusterCounts[label] = (clusterCounts[label] || 0) + 1;
                }
            }
            
            // 如果聚类数小于等于2，直接返回
            if (Object.keys(clusterCounts).length <= 2) {
                return newLabels;
            }
            
            // 只保留两个最大的聚类
            const sortedClusters = Object.entries(clusterCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 2);
            
            // 重新分配标签
            const labelMap = {};
            sortedClusters.forEach(([clusterId], index) => {
                labelMap[clusterId] = index;
            });
            
            for (let i = 0; i < m; i++) {
                if (newLabels[i] !== -1 && labelMap[newLabels[i]] !== undefined) {
                    newLabels[i] = labelMap[newLabels[i]];
                } else if (newLabels[i] !== -1) {
                    // 将其他聚类的点分配到最近的聚类
                    newLabels[i] = 0; // 默认分配到第一个聚类
                }
            }
            
            return newLabels;
        }
        
        // 计算DBSCAN的聚类中心点
        function calculateDBSCANCentroids(X, labels) {
            const uniqueLabels = [...new Set(labels)].filter(l => l !== -1);
            const n_features = X[0].length;
            const centroids = {};
            
            for (let label of uniqueLabels) {
                const clusterPoints = [];
                for (let i = 0; i < labels.length; i++) {
                    if (labels[i] === label) {
                        clusterPoints.push(X[i]);
                    }
                }
                
                if (clusterPoints.length > 0) {
                    const centroid = new Array(n_features).fill(0);
                    for (let d = 0; d < n_features; d++) {
                        let sum = 0;
                        for (let point of clusterPoints) {
                            sum += point[d];
                        }
                        centroid[d] = sum / clusterPoints.length;
                    }
                    centroids[label] = centroid;
                }
            }
            
            return centroids;
        }
        
        // 计算DBSCAN的PRF1指标
        function calculatePRF1ForDBSCAN(labels) {
            // 统计每个聚类的样本数
            const clusterCounts = {};
            for (let label of labels) {
                if (label !== -1) {
                    clusterCounts[label] = (clusterCounts[label] || 0) + 1;
                }
            }
            
            // 找到最大的簇作为正例，最小的簇作为反例
            const clusterEntries = Object.entries(clusterCounts);
            if (clusterEntries.length < 2) {
                return {
                    TP: 0,
                    FP: 0,
                    FN: 0,
                    TN: 0,
                    precision: 0,
                    recall: 0,
                    f1: 0,
                    f1_simplified: 0,
                    positive_cluster: -1,
                    negative_cluster: -1,
                    positive_cluster_size: 0,
                    negative_cluster_size: 0
                };
            }
            
            // 按簇大小排序
            clusterEntries.sort((a, b) => b[1] - a[1]);
            
            const positiveClusterIdx = parseInt(clusterEntries[0][0]);
            const negativeClusterIdx = parseInt(clusterEntries[clusterEntries.length - 1][0]);
            
            const positiveClusterSize = clusterEntries[0][1];
            const negativeClusterSize = clusterEntries[clusterEntries.length - 1][1];
            
            // 计算混淆矩阵
            let TP = 0, FP = 0, FN = 0, TN = 0;
            
            for (let i = 0; i < labels.length; i++) {
                if (labels[i] === positiveClusterIdx) {
                    TP++;
                } else if (labels[i] === negativeClusterIdx) {
                    TN++;
                } else if (labels[i] !== -1) {
                    // 其他聚类被视为假正例
                    FP++;
                }
                // 噪声点(-1)不参与计算
            }
            
            // 计算查准率、查全率和F1
            const P = TP / (TP + FP) || 0;
            const R = TP / (TP + FN) || 0;
            const F1 = (2 * P * R) / (P + R) || 0;
            
            // 使用简化公式：F1 = 2 * TP / (样例总数 + TP - TN)
            const totalSamples = labels.filter(l => l !== -1).length; // 排除噪声点
            const F1_simplified = totalSamples > 0 ? (2 * TP) / (totalSamples + TP - TN) : 0;
            
            return {
                TP: TP,
                FP: FP,
                FN: FN,
                TN: TN,
                precision: P,
                recall: R,
                f1: F1,
                f1_simplified: F1_simplified,
                positive_cluster: positiveClusterIdx,
                negative_cluster: negativeClusterIdx,
                positive_cluster_size: positiveClusterSize,
                negative_cluster_size: negativeClusterSize
            };
        }
        
        // 显示K-Means结果
        function displayKMeansResults(result) {
            let html = '';
            
            // 算法日志
            html += `<div style="background-color: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px; font-family: monospace; font-size: 0.9rem; white-space: pre-wrap;">${result.log}</div>`;
            
            // 显示PRF1指标
            const prf1 = result.prf1;
            html += `<div class="prf1-metrics">`;
            html += `<div class="prf1-title"><i class="fas fa-chart-line"></i> K-Means PRF1指标（最大簇为正例，最小簇为反例）</div>`;
            html += `<div class="prf1-grid">`;
            html += `<div class="prf1-item"><div class="prf1-value">${prf1.precision.toFixed(4)}</div><div class="prf1-label">查准率(P)</div></div>`;
            html += `<div class="prf1-item"><div class="prf1-value">${prf1.recall.toFixed(4)}</div><div class="prf1-label">查全率(R)</div></div>`;
            html += `<div class="prf1-item"><div class="prf1-value">${prf1.f1.toFixed(4)}</div><div class="prf1-label">F1值</div></div>`;
            html += `<div class="prf1-item"><div class="prf1-value">${prf1.f1_simplified.toFixed(4)}</div><div class="prf1-label">F1简化公式</div></div>`;
            html += `</div>`;
            
            // 显示混淆矩阵信息
            html += `<div style="margin-top: 15px; font-size: 0.9rem;">`;
            html += `<div>混淆矩阵：TP=${prf1.TP}, FP=${prf1.FP}, FN=${prf1.FN}, TN=${prf1.TN}</div>`;
            html += `<div>正例簇：簇${prf1.positive_cluster} (${prf1.positive_cluster_size}个样本)</div>`;
            html += `<div>反例簇：簇${prf1.negative_cluster} (${prf1.negative_cluster_size}个样本)</div>`;
            html += `</div>`;
            html += `</div>`;
            
            // 聚类统计
            html += `<div class="result-stats">`;
            const uniqueLabels = [...new Set(result.labels)];
            uniqueLabels.forEach((label, index) => {
                const count = result.labels.filter(l => l === label).length;
                const isPositive = label === prf1.positive_cluster;
                const isNegative = label === prf1.negative_cluster;
                let extraClass = '';
                let extraText = '';
                
                if (isPositive) {
                    extraClass = ' kmeans';
                    extraText = ' (正例)';
                } else if (isNegative) {
                    extraText = ' (反例)';
                }
                
                html += `<div class="stat-box${extraClass}"><div class="stat-value">${count}</div><div class="stat-label">簇 ${label}${extraText}</div></div>`;
            });
            html += `<div class="stat-box"><div class="stat-value">${result.n_samples}</div><div class="stat-label">总样本数</div></div>`;
            html += `<div class="stat-box"><div class="stat-value">${result.n_features}</div><div class="stat-label">特征数量</div></div>`;
            html += `<div class="stat-box"><div class="stat-value">${uniqueLabels.length}</div><div class="stat-label">聚类数量</div></div>`;
            html += `</div>`;
            
            // 显示每一簇的均值点
            html += `<div class="mean-points">`;
            html += `<h3>每一簇的均值点坐标:</h3>`;
            const centroids = result.centroids;
            const features = result.features;
            
            for (let i = 0; i < centroids.length; i++) {
                const centroid = centroids[i];
                const isPositive = i === prf1.positive_cluster;
                const isNegative = i === prf1.negative_cluster;
                let extraText = '';
                
                if (isPositive) {
                    extraText = ' <span style="color: #e74c3c;">(正例)</span>';
                } else if (isNegative) {
                    extraText = ' <span style="color: #3498db;">(反例)</span>';
                }
                
                html += `<div style="margin-bottom: 10px;">`;
                html += `<div style="font-weight: 600; color: ${isPositive ? '#e74c3c' : (isNegative ? '#3498db' : '#2c3e50')};">簇 ${i} 均值点${extraText}:</div>`;
                for (let j = 0; j < features.length; j++) {
                    html += `<span class="mean-point">${features[j]}: ${centroid[j].toFixed(3)}</span>`;
                }
                html += `</div>`;
            }
            html += `</div>`;
            
            // 可视化图表
            html += `<div class="side-by-side-charts">`;
            html += `<div class="side-by-side-chart-box"><div class="chart-title">K-Means聚类结果</div><div class="side-by-side-chart-container"><canvas id="kmeansChart"></canvas></div></div>`;
            html += `</div>`;
            
            kmeansResults.innerHTML = html;
            
            // 绘制图表 - 使用setTimeout确保DOM已更新
            setTimeout(() => {
                visualizeKMeansResults(result);
            }, 300);
        }
        
        // 显示DBSCAN结果
        function displayDBSCANResults(result) {
            let html = '';
            
            // 算法参数和统计
            html += `<div style="background-color: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px; font-family: monospace; font-size: 0.9rem;">`;
            html += `DBSCAN算法参数:<br>`;
            html += `ε (eps): ${result.eps.toFixed(4)}<br>`;
            html += `MinPts (min_samples): ${result.min_samples}<br>`;
            html += `原始数据: ${currentData.length}个样本<br>`;
            html += `有效数据: ${result.n_samples}个样本<br>`;
            html += `无效数据: ${result.invalid_data_count || 0}个样本<br><br>`;
            html += `聚类统计:<br>`;
            
            // 统计每个聚类的样本数
            const clusterCounts = {};
            for (let label of result.labels) {
                if (label !== -1) {
                    clusterCounts[label] = (clusterCounts[label] || 0) + 1;
                }
            }
            
            Object.entries(clusterCounts).forEach(([label, count]) => {
                html += `聚类${label}: ${count}个样本<br>`;
            });
            
            html += `噪声点: ${result.noise_count}个<br>`;
            html += `噪声比例: ${(result.noise_count / result.n_samples * 100).toFixed(2)}%`;
            html += `</div>`;
            
            // 显示PRF1指标
            const prf1 = result.prf1;
            html += `<div class="prf1-metrics">`;
            html += `<div class="prf1-title"><i class="fas fa-chart-line"></i> DBSCAN PRF1指标（最大簇为正例，最小簇为反例）</div>`;
            html += `<div class="prf1-grid">`;
            html += `<div class="prf1-item"><div class="prf1-value">${prf1.precision.toFixed(4)}</div><div class="prf1-label">查准率(P)</div></div>`;
            html += `<div class="prf1-item"><div class="prf1-value">${prf1.recall.toFixed(4)}</div><div class="prf1-label">查全率(R)</div></div>`;
            html += `<div class="prf1-item"><div class="prf1-value">${prf1.f1.toFixed(4)}</div><div class="prf1-label">F1值</div></div>`;
            html += `<div class="prf1-item"><div class="prf1-value">${prf1.f1_simplified.toFixed(4)}</div><div class="prf1-label">F1简化公式</div></div>`;
            html += `</div>`;
            
            // 显示混淆矩阵信息
            html += `<div style="margin-top: 15px; font-size: 0.9rem;">`;
            html += `<div>混淆矩阵：TP=${prf1.TP}, FP=${prf1.FP}, FN=${prf1.FN}, TN=${prf1.TN}</div>`;
            html += `<div>正例簇：簇${prf1.positive_cluster} (${prf1.positive_cluster_size}个样本)</div>`;
            html += `<div>反例簇：簇${prf1.negative_cluster} (${prf1.negative_cluster_size}个样本)</div>`;
            html += `</div>`;
            html += `</div>`;
            
            // 显示无效数据信息
            if (result.invalid_data_count > 0) {
                html += `<div class="invalid-data-info">`;
                html += `<i class="fas fa-exclamation-triangle"></i> 检测到 ${result.invalid_data_count} 个无效数据点（包含NaN或非数值数据），已在分析前自动过滤。`;
                html += `</div>`;
            }
            
            // 显示每一簇的均值点
            html += `<div class="mean-points">`;
            html += `<h3>每一簇的均值点坐标:</h3>`;
            const centroids = result.centroids;
            const features = result.features;
            
            Object.keys(centroids).forEach(label => {
                const centroid = centroids[label];
                const isPositive = parseInt(label) === prf1.positive_cluster;
                const isNegative = parseInt(label) === prf1.negative_cluster;
                let extraText = '';
                
                if (isPositive) {
                    extraText = ' <span style="color: #2ecc71;">(正例)</span>';
                } else if (isNegative) {
                    extraText = ' <span style="color: #3498db;">(反例)</span>';
                }
                
                html += `<div style="margin-bottom: 10px;">`;
                html += `<div style="font-weight: 600; color: ${isPositive ? '#2ecc71' : (isNegative ? '#3498db' : '#2c3e50')};">簇 ${label} 均值点${extraText}:</div>`;
                for (let j = 0; j < features.length; j++) {
                    html += `<span class="mean-point">${features[j]}: ${centroid[j].toFixed(3)}</span>`;
                }
                html += `</div>`;
            });
            html += `</div>`;
            
            // 可视化图表
            html += `<div class="side-by-side-charts">`;
            html += `<div class="side-by-side-chart-box"><div class="chart-title">DBSCAN聚类结果</div><div class="side-by-side-chart-container"><canvas id="dbscanChart"></canvas></div></div>`;
            html += `</div>`;
            
            dbscanResults.innerHTML = html;
            
            // 绘制图表 - 使用setTimeout确保DOM已更新
            setTimeout(() => {
                visualizeDBSCANResults(result);
            }, 300);
        }
        
        // 显示对比结果
        function displayComparisonResults() {
            if (!kmeansResult || !dbscanResult) {
                comparisonResults.innerHTML = '<p style="color: #7f8c8d; text-align: center; margin-top: 50px;"><i class="fas fa-info-circle"></i> 请先运行两种算法</p>';
                return;
            }
            
            const kmeansPRF1 = kmeansResult.prf1;
            const dbscanPRF1 = dbscanResult.prf1;
            
            let html = '';
            
            // 算法对比指标
            html += `<div class="comparison-metrics">`;
            
            // 查准率对比
            html += `<div class="comparison-metric-card">`;
            html += `<div class="comparison-title">查准率(P)对比</div>`;
            html += `<div class="comparison-values">`;
            html += `<div class="algorithm-value ${kmeansPRF1.precision > dbscanPRF1.precision ? 'winner' : ''}">`;
            html += `<div class="algorithm-name kmeans-name">K-Means</div>`;
            html += `<div class="algorithm-metric-value">${kmeansPRF1.precision.toFixed(4)}</div>`;
            html += `</div>`;
            html += `<div class="algorithm-value ${dbscanPRF1.precision > kmeansPRF1.precision ? 'winner' : ''}">`;
            html += `<div class="algorithm-name dbscan-name">DBSCAN</div>`;
            html += `<div class="algorithm-metric-value">${dbscanPRF1.precision.toFixed(4)}</div>`;
            html += `</div>`;
            html += `</div>`;
            html += `</div>`;
            
            // 查全率对比
            html += `<div class="comparison-metric-card">`;
            html += `<div class="comparison-title">查全率(R)对比</div>`;
            html += `<div class="comparison-values">`;
            html += `<div class="algorithm-value ${kmeansPRF1.recall > dbscanPRF1.recall ? 'winner' : ''}">`;
            html += `<div class="algorithm-name kmeans-name">K-Means</div>`;
            html += `<div class="algorithm-metric-value">${kmeansPRF1.recall.toFixed(4)}</div>`;
            html += `</div>`;
            html += `<div class="algorithm-value ${dbscanPRF1.recall > kmeansPRF1.recall ? 'winner' : ''}">`;
            html += `<div class="algorithm-name dbscan-name">DBSCAN</div>`;
            html += `<div class="algorithm-metric-value">${dbscanPRF1.recall.toFixed(4)}</div>`;
            html += `</div>`;
            html += `</div>`;
            html += `</div>`;
            
            // F1值对比
            html += `<div class="comparison-metric-card">`;
            html += `<div class="comparison-title">F1值对比</div>`;
            html += `<div class="comparison-values">`;
            html += `<div class="algorithm-value ${kmeansPRF1.f1 > dbscanPRF1.f1 ? 'winner' : ''}">`;
            html += `<div class="algorithm-name kmeans-name">K-Means</div>`;
            html += `<div class="algorithm-metric-value">${kmeansPRF1.f1.toFixed(4)}</div>`;
            html += `</div>`;
            html += `<div class="algorithm-value ${dbscanPRF1.f1 > kmeansPRF1.f1 ? 'winner' : ''}">`;
            html += `<div class="algorithm-name dbscan-name">DBSCAN</div>`;
            html += `<div class="algorithm-metric-value">${dbscanPRF1.f1.toFixed(4)}</div>`;
            html += `</div>`;
            html += `</div>`;
            html += `</div>`;
            
            // 聚类数量对比
            html += `<div class="comparison-metric-card">`;
            html += `<div class="comparison-title">聚类数量对比</div>`;
            html += `<div class="comparison-values">`;
            html += `<div class="algorithm-value">`;
            html += `<div class="algorithm-name kmeans-name">K-Means</div>`;
            html += `<div class="algorithm-metric-value">${new Set(kmeansResult.labels).size}</div>`;
            html += `</div>`;
            html += `<div class="algorithm-value">`;
            html += `<div class="algorithm-name dbscan-name">DBSCAN</div>`;
            html += `<div class="algorithm-metric-value">${Object.keys(dbscanResult.centroids).length}</div>`;
            html += `</div>`;
            html += `</div>`;
            html += `</div>`;
            
            html += `</div>`;
            
            // PRF1指标详细对比
            html += `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 20px;">`;
            
            html += `<div style="background-color: white; border-radius: 8px; padding: 20px; box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08); border-left: 4px solid #e74c3c;">`;
            html += `<h3 style="color: #e74c3c; margin-bottom: 15px;"><i class="fas fa-cube"></i> K-Means PRF1详情</h3>`;
            html += `<div style="color: #555; line-height: 1.6;">`;
            html += `<div>查准率(P): ${kmeansPRF1.precision.toFixed(4)}</div>`;
            html += `<div>查全率(R): ${kmeansPRF1.recall.toFixed(4)}</div>`;
            html += `<div>F1值: ${kmeansPRF1.f1.toFixed(4)}</div>`;
            html += `<div>F1(简化): ${kmeansPRF1.f1_simplified.toFixed(4)}</div>`;
            html += `<div>正例簇: 簇${kmeansPRF1.positive_cluster} (${kmeansPRF1.positive_cluster_size}样本)</div>`;
            html += `<div>反例簇: 簇${kmeansPRF1.negative_cluster} (${kmeansPRF1.negative_cluster_size}样本)</div>`;
            html += `</div>`;
            html += `</div>`;
            
            html += `<div style="background-color: white; border-radius: 8px; padding: 20px; box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08); border-left: 4px solid #2ecc71;">`;
            html += `<h3 style="color: #2ecc71; margin-bottom: 15px;"><i class="fas fa-project-diagram"></i> DBSCAN PRF1详情</h3>`;
            html += `<div style="color: #555; line-height: 1.6;">`;
            html += `<div>查准率(P): ${dbscanPRF1.precision.toFixed(4)}</div>`;
            html += `<div>查全率(R): ${dbscanPRF1.recall.toFixed(4)}</div>`;
            html += `<div>F1值: ${dbscanPRF1.f1.toFixed(4)}</div>`;
            html += `<div>F1(简化): ${dbscanPRF1.f1_simplified.toFixed(4)}</div>`;
            html += `<div>正例簇: 簇${dbscanPRF1.positive_cluster} (${dbscanPRF1.positive_cluster_size}样本)</div>`;
            html += `<div>反例簇: 簇${dbscanPRF1.negative_cluster} (${dbscanPRF1.negative_cluster_size}样本)</div>`;
            html += `<div>噪声点: ${dbscanResult.noise_count} (${(dbscanResult.noise_count / dbscanResult.n_samples * 100).toFixed(1)}%)</div>`;
            html += `</div>`;
            html += `</div>`;
            
            html += `</div>`;
            
            // 可视化对比图表
            html += `<div class="side-by-side-charts">`;
            html += `<div class="side-by-side-chart-box"><div class="chart-title">K-Means聚类结果</div><div class="side-by-side-chart-container"><canvas id="comparisonKMeansChart"></canvas></div></div>`;
            html += `<div class="side-by-side-chart-box"><div class="chart-title">DBSCAN聚类结果</div><div class="side-by-side-chart-container"><canvas id="comparisonDBSCANChart"></canvas></div></div>`;
            html += `</div>`;
            
            // 算法特点总结
            html += `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 30px;">`;
            
            html += `<div style="background-color: white; border-radius: 8px; padding: 20px; box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08); border-left: 4px solid #e74c3c;">`;
            html += `<h3 style="color: #e74c3c; margin-bottom: 15px;"><i class="fas fa-cube"></i> K-Means特点</h3>`;
            html += `<ul style="color: #555; line-height: 1.6; padding-left: 20px;">`;
            html += `<li>需要预先指定聚类数量k</li>`;
            html += `<li>对球形聚类效果较好</li>`;
            html += `<li>对噪声和异常值敏感</li>`;
            html += `<li>收敛速度较快</li>`;
            html += `<li>适用于数据分布均匀的情况</li>`;
            html += `</ul>`;
            html += `</div>`;
            
            html += `<div style="background-color: white; border-radius: 8px; padding: 20px; box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08); border-left: 4px solid #2ecc71;">`;
            html += `<h3 style="color: #2ecc71; margin-bottom: 15px;"><i class="fas fa-project-diagram"></i> DBSCAN特点</h3>`;
            html += `<ul style="color: #555; line-height: 1.6; padding-left: 20px;">`;
            html += `<li>自动确定聚类数量</li>`;
            html += `<li>能发现任意形状的聚类</li>`;
            html += `<li>能识别并处理噪声点</li>`;
            html += `<li>支持自动参数优化</li>`;
            html += `<li>减少噪声误判</li>`;
            html += `<li>适用于密度不均匀的数据</li>`;

            html += `<li>自动过滤无效数据</li>`;
            html += `</ul>`;
            html += `</div>`;
            
            html += `</div>`;
            
            comparisonResults.innerHTML = html;
            
            // 绘制对比图表 - 使用setTimeout确保DOM已更新
            setTimeout(() => {
                visualizeComparisonResults(kmeansResult, dbscanResult);
            }, 500);
        }
        
        // 可视化K-Means结果
        function visualizeKMeansResults(result) {
            const canvas = document.getElementById('kmeansChart');
            if (!canvas) {
                console.error('K-Means图表Canvas元素未找到');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            
            // 销毁之前的图表
            if (kmeansChart) {
                kmeansChart.destroy();
            }
            
            const X = result.X;
            const labels = result.labels;
            const features = result.features;
            
            if (features.length < 2) {
                canvas.parentElement.innerHTML = '<p style="color: #7f8c8d; text-align: center; padding: 20px;">需要至少2个特征才能绘制散点图</p>';
                return;
            }
            
            const uniqueLabels = [...new Set(labels)];
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c'];
            
            // 获取正例簇和反例簇
            const prf1 = result.prf1;
            const positiveCluster = prf1.positive_cluster;
            const negativeCluster = prf1.negative_cluster;
            
            const datasets = uniqueLabels.map((label, index) => {
                const clusterData = [];
                for (let i = 0; i < labels.length; i++) {
                    if (labels[i] === label) {
                        const point = { x: X[i][0], y: X[i][1] };
                        clusterData.push(point);
                    }
                }
                
                let pointStyle = 'circle';
                if (label === positiveCluster) {
                    pointStyle = 'rect';
                } else if (label === negativeCluster) {
                    pointStyle = 'triangle';
                }
                
                return {
                    label: `簇 ${label}${label === positiveCluster ? ' (正例)' : (label === negativeCluster ? ' (反例)' : '')}`,
                    data: clusterData,
                    backgroundColor: colors[index % colors.length] + '80', // 80表示50%透明度
                    borderColor: colors[index % colors.length],
                    pointRadius: 6,
                    pointHoverRadius: 7,
                    pointBorderWidth: 1,
                    pointBorderColor: '#fff',
                    pointStyle: pointStyle
                };
            });
            
            // 添加均值点数据集
            const centroids = result.centroids;
            const centroidData = centroids.map((centroid, index) => ({
                x: centroid[0],
                y: centroid[1]
            }));
            
            datasets.push({
                label: '均值点',
                data: centroidData,
                backgroundColor: '#2c3e50',
                borderColor: '#2c3e50',
                pointRadius: 10,
                pointHoverRadius: 12,
                pointStyle: 'star'
            });
            
            // 创建图表
            try {
                kmeansChart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            title: {
                                display: false
                            },
                            legend: {
                                position: 'top',
                                labels: {
                                    boxWidth: 12,
                                    font: {
                                        size: 10
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        if (context.dataset.label === '均值点') {
                                            return `均值点 ${context.dataIndex}: (${context.parsed.x.toFixed(2)}, ${context.parsed.y.toFixed(2)})`;
                                        }
                                        return `${context.dataset.label}: (${context.parsed.x.toFixed(2)}, ${context.parsed.y.toFixed(2)})`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: features[0],
                                    font: {
                                        size: 12
                                    }
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: features[1],
                                    font: {
                                        size: 12
                                    }
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('创建K-Means图表失败:', error);
            }
        }
        
        // 可视化DBSCAN结果
        function visualizeDBSCANResults(result) {
            const canvas = document.getElementById('dbscanChart');
            if (!canvas) {
                console.error('DBSCAN图表Canvas元素未找到');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            
            // 销毁之前的图表
            if (dbscanChart) {
                dbscanChart.destroy();
            }
            
            const X = result.X;
            const labels = result.labels;
            const features = result.features;
            
            if (features.length < 2) {
                canvas.parentElement.innerHTML = '<p style="color: #7f8c8d; text-align: center; padding: 20px;">需要至少2个特征才能绘制散点图</p>';
                return;
            }
            
            const colors = ['#e74c3c', '#3498db', '#2ecc71'];
            const datasets = [];
            
            // 获取正例簇和反例簇
            const prf1 = result.prf1;
            const positiveCluster = prf1.positive_cluster;
            const negativeCluster = prf1.negative_cluster;
            
            // 聚类0
            const cluster0Data = [];
            // 聚类1
            const cluster1Data = [];
            // 其他聚类
            const otherClustersData = [];
            // 噪声点
            const noiseData = [];
            
            for (let i = 0; i < labels.length; i++) {
                const point = { x: X[i][0], y: X[i][1] };
                if (labels[i] === 0) {
                    cluster0Data.push(point);
                } else if (labels[i] === 1) {
                    cluster1Data.push(point);
                } else if (labels[i] > 1) {
                    otherClustersData.push(point);
                } else if (labels[i] === -1) {
                    noiseData.push(point);
                }
            }
            
            // 添加正例簇
            if (positiveCluster !== -1) {
                const positiveData = [];
                for (let i = 0; i < labels.length; i++) {
                    if (labels[i] === positiveCluster) {
                        positiveData.push({ x: X[i][0], y: X[i][1] });
                    }
                }
                
                if (positiveData.length > 0) {
                    datasets.push({
                        label: `簇${positiveCluster} (正例)`,
                        data: positiveData,
                        backgroundColor: '#2ecc71' + '80', // 80表示50%透明度
                        borderColor: '#2ecc71',
                        pointRadius: 6,
                        pointHoverRadius: 7,
                        pointBorderWidth: 1,
                        pointBorderColor: '#fff',
                        pointStyle: 'rect'
                    });
                }
            }
            
            // 添加反例簇
            if (negativeCluster !== -1 && negativeCluster !== positiveCluster) {
                const negativeData = [];
                for (let i = 0; i < labels.length; i++) {
                    if (labels[i] === negativeCluster) {
                        negativeData.push({ x: X[i][0], y: X[i][1] });
                    }
                }
                
                if (negativeData.length > 0) {
                    datasets.push({
                        label: `簇${negativeCluster} (反例)`,
                        data: negativeData,
                        backgroundColor: '#3498db' + '80', // 80表示50%透明度
                        borderColor: '#3498db',
                        pointRadius: 6,
                        pointHoverRadius: 7,
                        pointBorderWidth: 1,
                        pointBorderColor: '#fff',
                        pointStyle: 'triangle'
                    });
                }
            }
            
            // 添加其他聚类
            const otherClusters = [...new Set(labels)].filter(l => l !== -1 && l !== positiveCluster && l !== negativeCluster);
            otherClusters.forEach((label, index) => {
                const otherData = [];
                for (let i = 0; i < labels.length; i++) {
                    if (labels[i] === label) {
                        otherData.push({ x: X[i][0], y: X[i][1] });
                    }
                }
                
                if (otherData.length > 0) {
                    datasets.push({
                        label: `簇${label}`,
                        data: otherData,
                        backgroundColor: colors[(index + 2) % colors.length] + '80', // 80表示50%透明度
                        borderColor: colors[(index + 2) % colors.length],
                        pointRadius: 5,
                        pointHoverRadius: 6,
                        pointBorderWidth: 1,
                        pointBorderColor: '#fff'
                    });
                }
            });
            
            // 添加噪声点（使用不同的样式）
            if (noiseData.length > 0) {
                datasets.push({
                    label: '噪声点',
                    data: noiseData,
                    backgroundColor: '#95a5a6',
                    borderColor: '#95a5a6',
                    pointRadius: 4,
                    pointHoverRadius: 5,
                    pointStyle: 'crossRot'
                });
            }
            
            // 添加均值点数据集
            const centroids = result.centroids;
            const centroidData = Object.keys(centroids).map(label => ({
                x: centroids[label][0],
                y: centroids[label][1]
            }));
            
            if (centroidData.length > 0) {
                datasets.push({
                    label: '均值点',
                    data: centroidData,
                    backgroundColor: '#2c3e50',
                    borderColor: '#2c3e50',
                    pointRadius: 10,
                    pointHoverRadius: 12,
                    pointStyle: 'star'
                });
            }
            
            // 创建图表
            try {
                dbscanChart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            title: {
                                display: false
                            },
                            legend: {
                                position: 'top',
                                labels: {
                                    boxWidth: 12,
                                    font: {
                                        size: 10
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        if (context.dataset.label === '均值点') {
                                            return `均值点: (${context.parsed.x.toFixed(2)}, ${context.parsed.y.toFixed(2)})`;
                                        }
                                        return `${context.dataset.label}: (${context.parsed.x.toFixed(2)}, ${context.parsed.y.toFixed(2)})`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: features[0],
                                    font: {
                                        size: 12
                                    }
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: features[1],
                                    font: {
                                        size: 12
                                    }
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('创建DBSCAN图表失败:', error);
            }
        }
        
        // 可视化对比结果
        function visualizeComparisonResults(kmeansResult, dbscanResult) {
            // K-Means对比图表
            const kmeansCanvas = document.getElementById('comparisonKMeansChart');
            const dbscanCanvas = document.getElementById('comparisonDBSCANChart');
            
            if (!kmeansCanvas || !dbscanCanvas) {
                console.error('对比图表Canvas元素未找到');
                return;
            }
            
            const features = kmeansResult.features;
            
            if (features.length < 2) {
                kmeansCanvas.parentElement.innerHTML = '<p style="color: #7f8c8d; text-align: center; padding: 20px;">需要至少2个特征才能绘制散点图</p>';
                dbscanCanvas.parentElement.innerHTML = '<p style="color: #7f8c8d; text-align: center; padding: 20px;">需要至少2个特征才能绘制散点图</p>';
                return;
            }
            
            // 绘制K-Means图表
            const kmeansCtx = kmeansCanvas.getContext('2d');
            const kmeansLabels = kmeansResult.labels;
            const X = kmeansResult.X;
            
            const kmeansUniqueLabels = [...new Set(kmeansLabels)];
            const kmeansColors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c'];
            
            // 获取K-Means正例簇和反例簇
            const kmeansPRF1 = kmeansResult.prf1;
            const kmeansPositiveCluster = kmeansPRF1.positive_cluster;
            const kmeansNegativeCluster = kmeansPRF1.negative_cluster;
            
            const kmeansDatasets = kmeansUniqueLabels.map((label, index) => {
                const clusterData = [];
                for (let i = 0; i < kmeansLabels.length; i++) {
                    if (kmeansLabels[i] === label) {
                        const point = { x: X[i][0], y: X[i][1] };
                        clusterData.push(point);
                    }
                }
                
                let pointStyle = 'circle';
                if (label === kmeansPositiveCluster) {
                    pointStyle = 'rect';
                } else if (label === kmeansNegativeCluster) {
                    pointStyle = 'triangle';
                }
                
                return {
                    label: `簇${label}${label === kmeansPositiveCluster ? ' (正例)' : (label === kmeansNegativeCluster ? ' (反例)' : '')}`,
                    data: clusterData,
                    backgroundColor: kmeansColors[index % kmeansColors.length] + '80',
                    borderColor: kmeansColors[index % kmeansColors.length],
                    pointRadius: 5,
                    pointHoverRadius: 6,
                    pointBorderWidth: 1,
                    pointBorderColor: '#fff',
                    pointStyle: pointStyle
                };
            });
            
            // 添加K-Means均值点
            const kmeansCentroids = kmeansResult.centroids;
            const kmeansCentroidData = kmeansCentroids.map((centroid, index) => ({
                x: centroid[0],
                y: centroid[1]
            }));
            
            kmeansDatasets.push({
                label: '均值点',
                data: kmeansCentroidData,
                backgroundColor: '#2c3e50',
                borderColor: '#2c3e50',
                pointRadius: 8,
                pointHoverRadius: 10,
                pointStyle: 'star'
            });
            
            // 绘制K-Means对比图表
            try {
                const kmeansChart = new Chart(kmeansCtx, {
                    type: 'scatter',
                    data: {
                        datasets: kmeansDatasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            title: {
                                display: false
                            },
                            legend: {
                                position: 'top',
                                labels: {
                                    boxWidth: 10,
                                    font: {
                                        size: 9
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: features[0],
                                    font: {
                                        size: 11
                                    }
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: features[1],
                                    font: {
                                        size: 11
                                    }
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('创建K-Means对比图表失败:', error);
            }
            
            // 绘制DBSCAN图表
            const dbscanCtx = dbscanCanvas.getContext('2d');
            const dbscanLabels = dbscanResult.labels;
            const dbscanColors = ['#e74c3c', '#3498db', '#2ecc71'];
            const dbscanDatasets = [];
            
            // 获取DBSCAN正例簇和反例簇
            const dbscanPRF1 = dbscanResult.prf1;
            const dbscanPositiveCluster = dbscanPRF1.positive_cluster;
            const dbscanNegativeCluster = dbscanPRF1.negative_cluster;
            
            // 添加正例簇
            if (dbscanPositiveCluster !== -1) {
                const positiveData = [];
                for (let i = 0; i < dbscanLabels.length; i++) {
                    if (dbscanLabels[i] === dbscanPositiveCluster) {
                        const point = { x: X[i][0], y: X[i][1] };
                        positiveData.push(point);
                    }
                }
                
                if (positiveData.length > 0) {
                    dbscanDatasets.push({
                        label: `簇${dbscanPositiveCluster} (正例)`,
                        data: positiveData,
                        backgroundColor: '#2ecc71' + '80',
                        borderColor: '#2ecc71',
                        pointRadius: 5,
                        pointHoverRadius: 6,
                        pointBorderWidth: 1,
                        pointBorderColor: '#fff',
                        pointStyle: 'rect'
                    });
                }
            }
            
            // 添加反例簇
            if (dbscanNegativeCluster !== -1 && dbscanNegativeCluster !== dbscanPositiveCluster) {
                const negativeData = [];
                for (let i = 0; i < dbscanLabels.length; i++) {
                    if (dbscanLabels[i] === dbscanNegativeCluster) {
                        const point = { x: X[i][0], y: X[i][1] };
                        negativeData.push(point);
                    }
                }
                
                if (negativeData.length > 0) {
                    dbscanDatasets.push({
                        label: `簇${dbscanNegativeCluster} (反例)`,
                        data: negativeData,
                        backgroundColor: '#3498db' + '80',
                        borderColor: '#3498db',
                        pointRadius: 5,
                        pointHoverRadius: 6,
                        pointBorderWidth: 1,
                        pointBorderColor: '#fff',
                        pointStyle: 'triangle'
                    });
                }
            }
            
            // 添加其他聚类
            const otherClusters = [...new Set(dbscanLabels)].filter(l => l !== -1 && l !== dbscanPositiveCluster && l !== dbscanNegativeCluster);
            otherClusters.forEach((label, index) => {
                const otherData = [];
                for (let i = 0; i < dbscanLabels.length; i++) {
                    if (dbscanLabels[i] === label) {
                        const point = { x: X[i][0], y: X[i][1] };
                        otherData.push(point);
                    }
                }
                
                if (otherData.length > 0) {
                    dbscanDatasets.push({
                        label: `簇${label}`,
                        data: otherData,
                        backgroundColor: dbscanColors[(index + 2) % dbscanColors.length] + '80',
                        borderColor: dbscanColors[(index + 2) % dbscanColors.length],
                        pointRadius: 4,
                        pointHoverRadius: 5,
                        pointBorderWidth: 1,
                        pointBorderColor: '#fff'
                    });
                }
            });
            
            // 添加噪声点
            const noiseData = [];
            for (let i = 0; i < dbscanLabels.length; i++) {
                if (dbscanLabels[i] === -1) {
                    noiseData.push({ x: X[i][0], y: X[i][1] });
                }
            }
            
            if (noiseData.length > 0) {
                dbscanDatasets.push({
                    label: '噪声点',
                    data: noiseData,
                    backgroundColor: '#95a5a6',
                    borderColor: '#95a5a6',
                    pointRadius: 3,
                    pointHoverRadius: 4,
                    pointStyle: 'crossRot'
                });
            }
            
            // 添加DBSCAN均值点
            const dbscanCentroids = dbscanResult.centroids;
            const dbscanCentroidData = Object.keys(dbscanCentroids).map(label => ({
                x: dbscanCentroids[label][0],
                y: dbscanCentroids[label][1]
            }));
            
            if (dbscanCentroidData.length > 0) {
                dbscanDatasets.push({
                    label: '均值点',
                    data: dbscanCentroidData,
                    backgroundColor: '#2c3e50',
                    borderColor: '#2c3e50',
                    pointRadius: 8,
                    pointHoverRadius: 10,
                    pointStyle: 'star'
                });
            }
            
            // 绘制DBSCAN对比图表
            try {
                const dbscanChart = new Chart(dbscanCtx, {
                    type: 'scatter',
                    data: {
                        datasets: dbscanDatasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            title: {
                                display: false
                            },
                            legend: {
                                position: 'top',
                                labels: {
                                    boxWidth: 10,
                                    font: {
                                        size: 9
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: features[0],
                                    font: {
                                        size: 11
                                    }
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: features[1],
                                    font: {
                                        size: 11
                                    }
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('创建DBSCAN对比图表失败:', error);
            }
        }
        
        // 添加日志
        function addLog(message, type = 'info') {
            const now = new Date();
            const timeString = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
            
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            
            const timeSpan = document.createElement('span');
            timeSpan.className = 'log-time';
            timeSpan.textContent = `[${timeString}]`;
            
            const messageSpan = document.createElement('span');
            messageSpan.textContent = ` ${message}`;
            
            if (type === 'error') {
                messageSpan.style.color = '#e74c3c';
            } else if (type === 'success') {
                messageSpan.style.color = '#2ecc71';
            }
            
            logEntry.appendChild(timeSpan);
            logEntry.appendChild(messageSpan);
            
            logOutput.appendChild(logEntry);
            
            // 自动滚动到底部
            logOutput.scrollTop = logOutput.scrollHeight;
        }
        
        // 更新状态
        function updateStatus(status, text) {
            statusDot.className = 'status-dot ' + status;
            statusText.textContent = text;
        }
        
        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // 添加seedrandom函数
        Math.seedrandom = function(seed) {
            let value = seed;
            return function() {
                value = (value * 9301 + 49297) % 233280;
                return value / 233280;
            };
        };
    </script>
</body>
</html>
